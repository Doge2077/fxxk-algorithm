# 刷穿力扣

****

## [1. 两数之和](https://leetcode.cn/problems/two-sum/)

****

- 哈希表
- 遍历数组，同时用 `HashMap` 维护已出现过的数及其下标
- 若当前的数 `nums[i]` 满足 `target - nums[i]` 曾经出现过，则直接返回
- 否则将其加入到哈希表中。

```java
class Solution {
     public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> st = new HashMap<>();
        for (int i = 0; i < nums.length; i ++) {
            if (st.containsKey(target - nums[i])) {
                return new int[]{st.get(target - nums[i]), i};
            }
            else st.put(nums[i], i);
        }
        return null;
    }
}
```

****

## [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

****

- 链表
- 使用 `res` 维护链表，`ans` 指向 `res` 头结点
- 遍历链表 `l1` 和 `l2`，取得当前节点的值分别为 `a`，`b` ，并用 `base` 记录进位
- 则，新的 `res` 节点为 `a + b + base % 10`，`base = (a + b + base) / 10`
- 不断将 `res` 更新为 `res.next`，最后若 `base != 0` 则补上进位即可

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode res = new ListNode();
        ListNode ans = res;
        int base = 0;
        while (l1 != null || l2 != null) {
            int a = l1 == null ? 0 : l1.val;
            int b = l2 == null ? 0 : l2.val;
            int sum = a + b + base;

            base = sum / 10;
            res.next = new ListNode(sum % 10);
            res = res.next;

            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        if (base != 0) res.next = new ListNode(base);
        return ans.next;
    }
}
```

****

## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

****

- 滑动窗口
- 常规做法维护一个集合或布尔数组，保存当前出现过的字符
- 设窗口左边界为 `i`，右边界为 `j`，当前字符为 `s[j]`
- 当出现重复字符时窗口左边界 `i` 向右移动，并不断将 `vis[i]` 移除，直到 `vis[i] === s[j]` 被排除
- 持续更新窗口最大长度 `j - i + 1` 即为答案

**优化**：

-  上述两种实现滑窗的方式都需要“持续性地移动边界”这个操作
-  不如换一种思路——使用 `HashMap` 来**更新每个字符最近一次出现的索引**
- 当我们遍历字符串 `s` 时，仍使用 `i` 和 `j` 来表示当前无重复字符子串的起始位置和结束位置，初始时 `i = j = 0`。
- 在每一步迭代中，检查当前字符 `s[j]` 是否已经在 `HashMap` 中存在：
    - 如果存在，则更新左指针 `i` 移动到重复字符的下一个位置，保证左指针 `i` 始终指向当前无重复字符子串的起始位置。
-  将 `s[j]` 其加入 `HashMap` 中，并更新窗口最大长度 `j - i + 1`。
-  最后，右指针 `j` 向右移动一位，继续遍历字符串 `s`，直到右指针 `j` 到达字符串的末尾
-  这样只需更新字符出现的索引即可，无需重复遍历。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int ans = 0;
        HashMap<Character, Integer> vis = new HashMap<>();
        int n = s.length();
        int i = 0, j = 0;
        while (i < n && j < n) {
            if (vis.containsKey(s.charAt(j))) {
                i = Math.max(vis.get(s.charAt(j)) + 1, i);  // 更新索引，取较大值为新的左指针位置
            }
            vis.put(s.charAt(j), j);  
            ans = Math.max(ans, j - i + 1);
            j ++;
        }
        return ans;
    }
}
```

****

## [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

****

- 暴力
- 合并两个有序数组，然后取中位数即可

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int[] nums = new int[n + m];
        int idx = 0, idx1 = 0, idx2 = 0;
        while (idx1 < n && idx2 < m) {
            if (nums1[idx1] < nums2[idx2]) nums[idx ++] = nums1[idx1 ++];
            else nums[idx ++] = nums2[idx2 ++];
        }
        while (idx1 < n) nums[idx ++] = nums1[idx1 ++];
        while (idx2 < m) nums[idx ++] = nums2[idx2 ++];
        if (((n + m) & 1) == 1) return nums[(n + m) >> 1];
        else return (double)(nums[(n + m) >> 1] + nums[(n + m - 1) >> 1]) / 2;
    }
}
```

****

## [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

****

- dp
- 在这种情况下，我们可以定义一个二维数组 `dp`，其中 `dp[i][j]` 表示从索引 `i` 到索引 `j` 的子串是否是回文。
- 根据回文的定义，我们可以得出以下状态转移方程：
    - `dp[i][j] = true`，如果 `i == j`（单个字符是回文）
    - `dp[i][j] = true`，如果 `s[i] == s[j]` 且 `dp[i + 1][j - 1] == true`（首尾字符相等且去掉首尾后的子串是回文）
    - `dp[i][j] = false`，其他情况
- 基于这个状态转移方程，我们可以使用动态规划来填充 `dp` 数组。然后，我们可以根据`dp`数组找到最长回文子串。

```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        String ans = "";
        
        // // 单个字符或相同的两个是回文
        for (int i = 0; i < n; i++) {
            if (ans.length() <= 1) ans = s.substring(i, i + 1);
            dp[i][i] = true;
            if (i < n - 1 && s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = true;
                ans = s.substring(i, i + 2);
            }
        }
        
        // 长度大于2的子串
        for (int len = 3; len <= n; len ++) {
            for (int i = 0; i <= n - len; i ++) {
                int j = i + len - 1;
                if (j - 1 >= 0 && s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    ans = s.substring(i, j + 1);
                }
            }
        }
        
        return ans;
    }
}
```

