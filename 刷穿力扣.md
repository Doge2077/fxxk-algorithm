# 刷穿力扣

****

## [1. 两数之和](https://leetcode.cn/problems/two-sum/)

****

- 哈希表
- 遍历数组，同时用 `HashMap` 维护已出现过的数及其下标
- 若当前的数 `nums[i]` 满足 `target - nums[i]` 曾经出现过，则直接返回
- 否则将其加入到哈希表中。

```java
class Solution {
     public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> st = new HashMap<>();
        for (int i = 0; i < nums.length; i ++) {
            if (st.containsKey(target - nums[i])) {
                return new int[]{st.get(target - nums[i]), i};
            }
            else st.put(nums[i], i);
        }
        return null;
    }
}
```

****

## [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

****

- 链表
- 使用 `res` 维护链表，`ans` 指向 `res` 头结点
- 遍历链表 `l1` 和 `l2`，取得当前节点的值分别为 `a`，`b` ，并用 `base` 记录进位
- 则，新的 `res` 节点为 `a + b + base % 10`，`base = (a + b + base) / 10`
- 不断将 `res` 更新为 `res.next`，最后若 `base != 0` 则补上进位即可

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode res = new ListNode();
        ListNode ans = res;
        int base = 0;
        while (l1 != null || l2 != null) {
            int a = (l1 != null) ? l1.val : 0;
            int b = (l2 != null) ? l2.val : 0;
            
            int sum = a + b + base;
            base = sum / 10;
            
            res.next = new ListNode(sum % 10);
            res = res.next;
            
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        
        if (base > 0) {
            res.next = new ListNode(base);
        }
        return ans.next;
    }
}
```

