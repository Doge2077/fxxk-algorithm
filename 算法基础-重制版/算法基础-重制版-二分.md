# 前言

****

- 本次重制版的算法计划采用 `Java`  实现，但对于部分练习的题目仍会给出 `C++` 题解
- 相较以往的算法版本，本次采用的练习题目都将为免费题目，且加大例题的练习数量
- 旧版是本人初学算法时期所作，不甚完美，重制版将带入自己的经验进行优化

****

# 二分

****

## 思想概述

****

二分算法是算竞最经典的算法，它几乎随处可见，请看下面的例子：

> 猜数字：给定某个数 $x, (1 \le x \le 100)$，每次猜数都会明确告诉你这个数相较 $x$ 是大还是小，你该如何快速猜对这个数是多少？
>
> 法一：从 $1$ 开始一个一个地猜，直到猜对为止
>
> 法二：先猜 $50$，如果小于 $x$ 则下次猜 $75$，否则猜 $25$，每次都取剩下一半区间的数，直到猜对为止

对于上述示例，法一没有用到题目的全部条件（明确当前猜的数和 $x$ 的大小），相较之下，法二则是效率极高的。

因为法二是基于二分的思想来实现的：

- 第一次猜数取范围的中间值 $50$，即取二分范围的中间值
- 第二次猜数根据第一次的判断再次确定范围，即将二分范围的中间值和目标值比较后确定下一次查找的区间

综上：每次查找取范围的中间值，然后根据区间的单调性来缩小查询范围，将查找范围减小为上一次查找的一半大小，直至找到目标值，显然，二分算法的时间复杂度一般为 $\mathcal{O}(log_2^N)$。

由此可见，二分算法是一种**高效查询某一区间内指定值**的算法，这里的**区间必须满足某种单调性质**——递增、递减或某种唯一性质的有序组合。

****

## 算法实现

****

由于二分查找取区间中间值的特殊性质，可以将其划分为整数二分和浮点数二分：

- 整数二分：满足绝大部分的二分应用场景，不针对区间进行限制
- 浮点数二分：针对区间范围要求精确到浮点数，很少见

****

### 整数二分

****

在**保证数组为从小到大升序排列**的情况下，这里我们给出 `Java` 的 `Arrays.binarySearch()` 方法的实现，该方法调用了 `binarySearch0` 方法：

```java
    // Like public version, but without range checks.
    private static int binarySearch0(int[] a, int fromIndex, int toIndex,
                                     int key) {
        int low = fromIndex;
        int high = toIndex - 1;

        while (low <= high) {
            int mid = (low + high) >>> 1;
            int midVal = a[mid];

            if (midVal < key)
                low = mid + 1;
            else if (midVal > key)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found.
    }
```

但为了适应算竞的需求，我们针对上述实现做一些改进：

```java
private static int bs (int l, int r, int target, int[] nums) {
	while (l <= r) {
        int mid = (l + r) >> 1;               // 计算区间中点
    	if (nums[mid] == target) return mid;  // 找到直接返回
    	if (nums[mid] < target) l = mid + 1;  // target 大，则 target 在左半部分，二分区间的左端点 l 要向右更新
    	else r = mid - 1;                     // target 小，则 target 在右半部分，二分区间的右端点 r 要向左更新
    }
    return nums[r] == target ? r : -1;
} 
```

- 若 `int mid = (l + r) >> 1` 其中 `l + r` 在某些条件下可能会发生溢出，因此可以改为 `int mid = l + (r - l) >> 1`
- 如果结束时仍没有找到目标值：
  - `l` 会落在最后一次不满足 `target` 的右边
  - `r` 会落在 `l - 1`，也就是最后一次不满足 `target` 的位置
- 对于 `return` 具体的返回值可以根据题目条件灵活修改，这里我们找不到目标值直接返回了 $-1$

****

### 浮点数二分

****

对于浮点数二分的应用场景十分局限，可能只有求根这种场景会使用到

```java
private static double bs (double l, double r, double target, double eps) {
    while (r - l > eps) {
        double mid = (l + r) / 2;
        if (mid < target) l = mid;
        else r = mid;
    }
    return l;
}
```

****

## 经典例题

****

### [搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

****

- 二分的板子题
- 利用二分找到指定的目标值即可
- 对于我们的算法模板来说，在结束时仍没有找到目标值：
  - `l` 会落在最后一次不满足 `target` 的右边，即应当插入的数的位置
  - `r` 会落在 `l - 1`，也就是最后一次不满足 `target` 的位置，即应当插入的数的前一个位置
- 因此，需要插入的位置应该是 `l` 或者 `r + 1`

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] == target) return mid;
            if (nums[mid] < target) l = mid + 1;
            else r = mid - 1;
        }
        return l;  // r + 1
    }
}
```

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
      int l = 0, r = nums.size() - 1;
      while (l <= r) {
          int mid = (l + r) >> 1;
          if (nums[mid] == target) return mid;
          if (nums[mid] < target) l = mid + 1;
          else r = mid -1;
      }
      return l;  // r + 1
    }
};
```

****
