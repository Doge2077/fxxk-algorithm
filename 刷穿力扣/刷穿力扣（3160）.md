# 刷穿力扣（31~60）

****

## [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

****

- 排列
- 原理就是 `C++` 中的 `next_permutation` 函数，生成指定序列的下一个全排列
- 从给定序列的最右端开始，找到第一个满足 `nums[i] < nums[i + 1]` 的元素 `nums[i]`
- 若找不到这样的元素 `nums[i]`：说明当前序列是最后一个排列，函数将序列重排为第一个排列，并返回 `false`
- 若找到了元素 `nums[i]`：继续从最右端开始，找到第一个满足 `nums[i] < nums[j]` 的元素 `nums[j]`。
- 交换 `nums[i]` 和 `nums[j]`，然后从 `i + 1` 开始将序列反转，使得它们按照升序排列。

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        int i = n - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) i --;
        if (i >= 0) {
            int j = n - 1;
            while (nums[j] <= nums[i]) j --;
            swap(nums, i, j);
        }
        reverse(nums, i + 1, n - 1);
    }

    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    private void reverse(int[] nums, int l, int r) {
        while (l < r) {
            this.swap(nums, l, r);
            l ++; r --;
        }
    }
    
}
```

****

## [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

****

- 栈
- 用 `Stack<Integer>` 存储所有 `(` 的下标
- 当遇到右括号时，检查栈是否为空：
    - 若栈为空，则说明当前右括号没有匹配的左括号，将当前右括号的位置作为新的起始位置。
    - 若不为空，则弹出栈顶元素，并更新当前有效括号的长度（当前右括号的位置减去栈顶元素的值）
- 遍历完字符串后，得到最长有效括号的长度

```java
class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> stack = new Stack<>();
        int ans = 0;
        int start = -1; // 有效括号序列的起始位置

        for (int i = 0; i < s.length(); i++) {
            // 将左括号的位置压入栈中
            if (s.charAt(i) == '(') stack.push(i); 
            else {
                if (stack.isEmpty()) {
                    start = i; // 当前右括号无法匹配，更新起始位置
                } 
                else {
                    stack.pop();
                    // 栈为空，表示当前右括号匹配到有效括号序列的末尾
                    if (stack.isEmpty()) ans = Math.max(ans, i - start);
                    else ans = Math.max(ans, i - stack.peek());  // 栈不为空，计算当前有效括号序列的长度
                }
            }
        }

        return ans;
    }
}
```

**优化**：

- 模拟
- 设当前的括号出现的次数 `res`，第一次扫代表 `(`，起始位置 `l = 0`，第二次扫代表 `)`，起始位置 `r = n - 1`
- 先从左往右扫一遍，若为 `(`，`res ++`；
- 当遇到 `)` 时:
    - 若 `res == 0`，则更新最长有效括号的长度 `ans`，并更新起始位置 `l`
    - 否则：说明匹配，`res --`，若此时 `res == 0`，则匹配了全部左括号，更新 `ans`
- 第一遍扫完后，判断是否还有未匹配的左括号。如果没有或者最长有效括号的长度 `ans` 已经大于等于剩余未匹配左括号的长度（n - l），则直接返回 `ans`。
- 如果还有未匹配的左括号，说明可能出现以右括号结尾的有效括号序列。再从右往左扫第二遍，步骤是一样的。
- 最终返回最长有效括号的长度 `ans`。

```java
class Solution {
    public int longestValidParentheses(String s) {
        int res = 0;
        int n = s.length();
        int ans = 0, l = 0;
        // 从左扫第一遍
        for (int i = 0; i < n; i ++) {
            if (s.charAt(i) == '(') {
                res ++; continue;
            }
            // 遇到右括号，且当前没有匹配的左括号
            if (res == 0) {
                ans = Math.max(ans, i - l);  // 更新最长有效括号的长度
                l = i + 1;  // 更新起始位置
            } 
            else {
                res --;  // 遇到右括号，且有匹配的左括号，res --
                if (res == 0) ans = Math.max(ans, i - l + 1);
            }
        }
         // 如果遍历完字符串后，仍有未匹配的左括号
        if (res == 0 || ans >= n - l) return ans;
        
        int r = n - 1; res = 0;
        // 从右扫第二遍
        for (int i = n - 1; i > l; i --) {
            if (s.charAt(i) == ')') {
                res ++; continue;
            }
            if (res == 0) {
                ans = Math.max(ans, r - i);
                r = i - 1;
            } 
            else 
                res --;
                if (res == 0) ans = Math.max(ans, r - i + 1);
            }
        }
        
        return ans;
    }
}
```

****

## [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

****

- 二分
- 显然，在旋转点的左侧满足 `nums[i] >= nums[0]`，而右侧 `nums[i] < nums[0]`
- 根据上述的单调性我们第一次二分找到旋转点的位置
- 然后判断 `target` 在旋转点的左半部分还是右半部分
- 显然，当 `target >= nums[0]` 时在左半部分
- 然后继续二分，更新 `l, r` 为新的目标区间继续查找

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        // 只有一个直接判断返回
        if (n == 1) return nums[0] == target ? 0 : -1;
        int l = 0, r = n - 1;
        int t = nums[0];
        // 若结果 l < r 则旋转点位置为 l, 若结果 l > r 则未找到
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] == target) return mid;
            if (nums[mid] >= t) l = mid + 1;
            else r = mid - 1;
        } 
        if (l < r && nums[l] == target) return l;
        if (target >= nums[0]) {
            r = l - 1; l = 0;  // 更新区间为左半部分
        }
        else {
            l ++; r = n - 1;   // 更新区间为右半部分
        }
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] == target) return mid;
            if (nums[mid] > target) r = mid - 1;
            else l = mid + 1;
        }
        return l < r ? l : -1;
    }
}
```

****
