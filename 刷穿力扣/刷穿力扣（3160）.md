# 刷穿力扣（31~60）

****

## [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

****

- 排列
- 原理就是 `C++` 中的 `next_permutation` 函数，生成指定序列的下一个全排列
- 从给定序列的最右端开始，找到第一个满足 `nums[i] < nums[i + 1]` 的元素 `nums[i]`
- 若找不到这样的元素 `nums[i]`：说明当前序列是最后一个排列，函数将序列重排为第一个排列，并返回 `false`
- 若找到了元素 `nums[i]`：继续从最右端开始，找到第一个满足 `nums[i] < nums[j]` 的元素 `nums[j]`。
- 交换 `nums[i]` 和 `nums[j]`，然后从 `i + 1` 开始将序列反转，使得它们按照升序排列。

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        int i = n - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) i --;
        if (i >= 0) {
            int j = n - 1;
            while (nums[j] <= nums[i]) j --;
            swap(nums, i, j);
        }
        reverse(nums, i + 1, n - 1);
    }

    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    private void reverse(int[] nums, int l, int r) {
        while (l < r) {
            this.swap(nums, l, r);
            l ++; r --;
        }
    }
    
}
```

****

## [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

****

- 栈
- 用 `Stack<Integer>` 存储所有 `(` 的下标
- 当遇到右括号时，检查栈是否为空：
    - 若栈为空，则说明当前右括号没有匹配的左括号，将当前右括号的位置作为新的起始位置。
    - 若不为空，则弹出栈顶元素，并更新当前有效括号的长度（当前右括号的位置减去栈顶元素的值）
- 遍历完字符串后，得到最长有效括号的长度

```java
class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> stack = new Stack<>();
        int ans = 0;
        int start = -1; // 有效括号序列的起始位置

        for (int i = 0; i < s.length(); i++) {
            // 将左括号的位置压入栈中
            if (s.charAt(i) == '(') stack.push(i); 
            else {
                if (stack.isEmpty()) {
                    start = i; // 当前右括号无法匹配，更新起始位置
                } 
                else {
                    stack.pop();
                    // 栈为空，表示当前右括号匹配到有效括号序列的末尾
                    if (stack.isEmpty()) ans = Math.max(ans, i - start);
                    else ans = Math.max(ans, i - stack.peek());  // 栈不为空，计算当前有效括号序列的长度
                }
            }
        }

        return ans;
    }
}
```

**优化**：

- 模拟
- 设当前的括号出现的次数 `res`，第一次扫代表 `(`，起始位置 `l = 0`，第二次扫代表 `)`，起始位置 `r = n - 1`
- 先从左往右扫一遍，若为 `(`，`res ++`；
- 当遇到 `)` 时:
    - 若 `res == 0`，则更新最长有效括号的长度 `ans`，并更新起始位置 `l`
    - 否则：说明匹配，`res --`，若此时 `res == 0`，则匹配了全部左括号，更新 `ans`
- 第一遍扫完后，判断是否还有未匹配的左括号。如果没有或者最长有效括号的长度 `ans` 已经大于等于剩余未匹配左括号的长度（n - l），则直接返回 `ans`。
- 如果还有未匹配的左括号，说明可能出现以右括号结尾的有效括号序列。再从右往左扫第二遍，步骤是一样的。
- 最终返回最长有效括号的长度 `ans`。

```java
class Solution {
    public int longestValidParentheses(String s) {
        int res = 0;
        int n = s.length();
        int ans = 0, l = 0;
        // 从左扫第一遍
        for (int i = 0; i < n; i ++) {
            if (s.charAt(i) == '(') {
                res ++; continue;
            }
            // 遇到右括号，且当前没有匹配的左括号
            if (res == 0) {
                ans = Math.max(ans, i - l);  // 更新最长有效括号的长度
                l = i + 1;  // 更新起始位置
            } 
            else {
                res --;  // 遇到右括号，且有匹配的左括号，res --
                if (res == 0) ans = Math.max(ans, i - l + 1);
            }
        }
         // 如果遍历完字符串后，仍有未匹配的左括号
        if (res == 0 || ans >= n - l) return ans;
        
        int r = n - 1; res = 0;
        // 从右扫第二遍
        for (int i = n - 1; i > l; i --) {
            if (s.charAt(i) == ')') {
                res ++; continue;
            }
            if (res == 0) {
                ans = Math.max(ans, r - i);
                r = i - 1;
            } 
            else 
                res --;
                if (res == 0) ans = Math.max(ans, r - i + 1);
            }
        }
        
        return ans;
    }
}
```

****

## [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

****

- 二分
- 显然，在旋转点的左侧满足 `nums[i] >= nums[0]`，而右侧 `nums[i] < nums[0]`
- 根据上述的单调性我们第一次二分找到旋转点的位置
- 然后判断 `target` 在旋转点的左半部分还是右半部分
- 显然，当 `target >= nums[0]` 时在左半部分
- 然后继续二分，更新 `l, r` 为新的目标区间继续查找

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if (n == 1) return nums[0] == target ? 0 : -1;
        int l = 0, r = n - 1;
        // 寻找旋转点，查找第一个不满足 >= nums[0] 的元素下标
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] == target) return mid;
            if (nums[mid] >= nums[0]) l = mid + 1;
            else r = mid - 1; 
        }
        if (l < n && nums[l] == target) return l;
       	// 判断 target 在左半区间还是右半区间
        if (target >= nums[0]) {
            r = l - 1; l = 0;  // 更新边界为左半区间
        }
        else {
            l ++; r = n - 1;   // 更新边界为右半区间
        }
        // 在剩下半个区间查找 == target 的元素下标
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] == target) return mid;
            if (nums[mid] < target) l = mid + 1;
            else r = mid - 1;
        }
        return l < n && nums[l] == target ? l : -1;
    }
}
```

****

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

****

- 二分
- 数组已从小到大排序，满足单调性
- 第一遍二分寻找第一个小于 `target` 的数，期间更新 `nums[mid] == target` 的下标，即为第一个位置
- 第二遍二分寻找第一个大于 `target` 的数，期间更新 `nums[mid] == target` 的下标，即为第二个位置

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length;
        int l = 0, r = n - 1;
        int res = -1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] == target) res = mid;
            if (nums[mid] < target) l = mid + 1;
            else r = mid - 1;
        }
        if (res == -1) return new int[]{-1, -1};
        l = res; r = n - 1;  // l 从 res 开始或 0 开始都行
        int cnt = -1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] == target) cnt = mid;
            if (nums[mid] > target) r = mid - 1;
            else l = mid + 1;
        }
        return new int[]{res, cnt};
    }
}
```

****

## [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

****

- 二分
- 没啥好说的板子题

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (nums[mid] == target) return mid;
            if (nums[mid] < target) l = mid + 1;
            else r = mid - 1;
        }
        return l;
    }
}
```

****

## [36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)

****

- 模拟
- 只需要验证已有的数是否符号规则就行，因此我们可以用~~区区十几个循环嵌套来解决~~
- 首先将数独按照 $3 \times 3$ 分为 $9$ 组，然后用 `boolean[][]` 维护每组格子的状态
- 具体滴，对于格子 `board[i][j]`，所在的组编号 `u` 映射为 `u = i / 3 * 3 + j / 3`
- 则  `boolean[][] vis[u][num]` 表示第 `u` 组数字 `num` 是否已经存在
-  那么除此之外，还需要判断行和列的格子的状态即可

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        boolean[][] vis = new boolean[10][10];  // 记录小方块的填数状态
        boolean[][] row = new boolean[10][10];  // 记录每一行的填数状态
        boolean[][] col = new boolean[10][10];  // 记录每一列的填数状态

        for (int i = 0; i < 9; i ++) {
            for (int j = 0; j < 9; j ++) {
                char t = board[i][j];
                if (t == '.') continue;  // '.' 无所谓，直接跳过
                int num = t - '0';
                // 组编号映射
                int u = i / 3 * 3 + j / 3;
                // 只要有一个已经存放过都不成立
                if (vis[u][num] || row[i][num] || col[j][num]) return false;
                vis[u][num] = row[i][num] = col[j][num] = true;
            }
        }
        return true;
    }
}
```

****

## [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

****

- DFS
- 对于 `board[i][j]` 从 $1 \sim 9$ 暴力搜索每一个可能的值
- 难点仍是在于判断是否合法，思路同上一题

```java
class Solution {
    public void solveSudoku(char[][] board) {
        boolean[][] vis = new boolean[10][10];  // 记录每个数字在每一行的填数状态
        boolean[][] row = new boolean[10][10];  // 记录每个数字在每一列的填数状态
        boolean[][] col = new boolean[10][10];  // 记录每个数字在每个小方块的填数状态
        init(board, vis, row, col);  // 初始化状态数组
        dfs(board, 0, 0, vis, row, col);
    }

    private boolean dfs(char[][] board, int i, int j, boolean[][] vis,
                    boolean[][] row, boolean[][] col) {
        if (i == 9) return true;  // 数独已经填满，返回 true
        if (j == 9) return dfs(board, i + 1, 0, vis, row, col);  // 当前行已经填完，转到下一行
        if (board[i][j] != '.') return dfs(board, i, j + 1, vis, row, col);  // 当前位置已经有数字，转到下一个位置
		// 从 1 开始枚举可能的值
        for (int num = 1; num <= 9; num ++) {
            int idx = i / 3 * 3 + j / 3;  // 小方块的索引
            if (!vis[idx][num] && !row[i][num] && !col[j][num]) {
                vis[idx][num] = row[i][num] = col[j][num] = true;
                board[i][j] = (char)(num + '0');  // 填入值
                if (dfs(board, i, j + 1, vis, row, col)) return true;  // 递归填下一个位置
                // 恢复现场
                vis[idx][num] = row[i][num] = col[j][num] = false;     
                board[i][j] = '.';
            }
        }
        return false;  // 无法填入任何数字，返回false
    }

    private void init(char[][] board, boolean[][] vis,
                    boolean[][] row, boolean[][] col) {
        for (int i = 0; i < 9; i ++) {
            for (int j = 0; j < 9; j ++) {
                if (board[i][j] != '.') {
                    int num = board[i][j] - '0';
                    int idx = i / 3 * 3 + j / 3;
                    vis[idx][num] = row[i][num] = col[j][num] = true;
                }
            }
        }
    }
}
```

