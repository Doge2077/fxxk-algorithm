# Hot100

****

## [1. 两数之和](https://leetcode.cn/problems/two-sum/)

****

- 哈希表
- 遍历数组，同时用 `HashMap` 维护已出现过的数及其下标
- 若当前的数 `nums[i]` 满足 `target - nums[i]` 曾经出现过，则直接返回
- 否则将其加入到哈希表中。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> st = new HashMap<>();
        for (int i = 0; i < nums.length; i ++) {
            int t = target - nums[i];
            if (st.containsKey(t)) {
                return new int[] {i, st.get(t)};
            }
            st.put(nums[i], i);
        }
        return null;
    }
}
```

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int, int> vis;
        vector<int> ans;
        for (int i = 0; i < nums.size(); i ++) {
            int t = target - nums[i];
            if (vis.find(t) != vis.end()) {
                ans.push_back(i); ans.push_back(vis[t]);
                return ans;
            } else {
                vis[nums[i]] = i;
            }
        }
        return ans;
    }
};
```

****

## [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

****

- 哈希表
- 遍历集合的 strs，对每个遍历到的字符串按照字典序进行排序
- 因此具有相同的字典序的字符串是同一组的异位词
- 利用哈希表用字典序映射对应组的下标
- 每次遍历将排序后的字符串在哈希表中找到其所属组的映射，然后加入该组即可

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> ans = new ArrayList<>();
        HashMap<String, Integer> vis = new HashMap<>();
        int idx = 0;
        for (String str : strs) {
            char s[] = str.toCharArray();
            Arrays.sort(s);
            String st = new String(s);
            if (vis.containsKey(st)) ans.get(vis.get(st)).add(str);
            else {
                List<String> cnt = new ArrayList<>();
                cnt.add(str); ans.add(cnt);
                vis.put(st, idx ++);
            }
        }
        return ans;
    }
}
```

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> ans;
        int idx = 0;
        map<string, int> vis;
        for (auto &p : strs) {
            string t = p;
            sort(t.begin(), t.end());
            if (vis.find(t) != vis.end()) ans[vis[t]].push_back(p);
            else {
                vector<string> st;
                st.push_back(p);
                ans.push_back(st);
                vis[t] = idx ++;
            }
        }
        return ans;
    }
};
```

****

## [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

****

- 哈希
- 用 Set 对原数组内元素去重
- 遍历 Set，如果当前 num - 1 不存在于 Set 中，说明该 num 可能为连续序列的起始点
- 则不断判断 num ++ 是否存在于 Set，并更新最大长度

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> st = new HashSet<>();
        for (int num : nums) st.add(num);
        int ans = 0;
        for (int num : nums) {
            if (!st.contains(num - 1)) {
                int t = num;
                int cnt = 1;
                while (st.contains(t + 1)) {
                    t ++; cnt ++;
                }
                ans = Math.max(cnt, ans);
            }
        }
        return ans;
    }
}
```

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        set<int> st;
        for (auto &p : nums) st.insert(p);
        int ans = 0;
        for (auto &p : st) {
            if (st.find(p - 1) == st.end()) {
                int t = p;
                int cnt = 1;
                while (st.find(t + 1) != st.end()) {
                    t ++, cnt ++;
                }
                ans = max(cnt, ans);
            }
        }
        return ans;
    }
};
```

****

## [283. 移动零](https://leetcode.cn/problems/move-zeroes/)

****

- 双指针
- 用 j 表示当前为 0 的位置，i 表示走到的不为 0 的位置
- 如果 i 向后遍历到某个位置不为 0，则交换 nums[i] 和 nums[j]
- 交换后，j ++
- 初始化 j = i = 0，即使 nums[j] != 0，交换后的 j ++ 会后移到 0 的位置

```java
class Solution {
    public void moveZeroes(int[] nums) {
        for (int i = 0, j = 0; i < nums.length; i ++) {
            if (nums[i] != 0) {
                int t = nums[i];
                nums[i] = nums[j];
                nums[j] = t;
                j ++;
            }
        }
    }
}	
```

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        for (int i = 0, j = 0; i < nums.size(); i ++) {
            if (nums[i] != 0) {
                swap(nums[i], nums[j]);
                j ++;
            }
        }
    }
};
```

****

## [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

****

朴素版本：

- 模拟
- 以 i 为左边界，j 为右边界，遍历取 ans 最大值
- 若 height[i] * (j - i) < ans 说明 j 左移不存在比 ans 大的值，直接 break

```java
class Solution {
    public int maxArea(int[] height) {
        int ans = 0;
        for (int i = 0; i < height.length; i ++) {
            for (int j = height.length - 1; j > i; j --) {
                if (height[i] * (j - i) < ans) break;
                ans = Math.max(ans, Math.min(height[i], height[j]) * (j - i));
            }
        }
        return ans;
    }
}
```

优化：

- 双指针
- 以 l 为左边界，r 为右边界
- 取当 t =  min(l, r)，则若（ l 向右移存在 height[l] > t）或 （r 向左移存在 height[r] > t）说明 ans 可能增大 

```java
class Solution { 
    public int maxArea(int[] height) {
        int n = height.length;
        int l = 0, r = n - 1;
        int ans = Math.min(height[l], height[r]) * (r - l);
        while (l < r) {
            int t = Math.min(height[l], height[r]);
            while (l < r && height[l] <= t) l ++;  // 快速找到第一个满足条件的左边界
            while (l < r && height[r] <= t) r --;  // 同理找到右边界
            ans = Math.max(ans, Math.min(height[r], height[l]) * (r - l));  // 更新答案
        }
        return ans;
    }
}
```

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        int l = 0, r = n - 1;
        int ans = min(height[l], height[r]) * (r - l);
        while (l < r) {
            int t = min(height[l], height[r]);
            while (l < r && height[l] <= t) l ++;
            while (l < r && height[r] <= t) r --;
            ans = max(ans, min(height[l], height[r]) * (r - l));
        }
        return ans;
    }
};
```

****

## [15. 三数之和](https://leetcode.cn/problems/3sum/)

****

- 双指针
- 首先对 nums 从小到大排序，使得其从小到大单调
- 遍历 nums[i]，对于每个 nums[i]，设 nums[i] 为三数之和中最小的数
- 利用双指针，在 nums[i] 的右边区间寻找符合条件的两个数
- 设左指针为 l = i + 1，右指针 r = nums.length - 1
- 若 nums[i] + nums[l] + nums[r] > 0 说明 r 需要向左移动，否则 l 需要向右移动
- 若 nums[i] + nums[l] + nums[r] == 0 说明是一个答案，需要记录
  - 特别地，nums[i] > 0 的情况下，左边区间一定是大于 0 的，不存在任何答案
- 注意，在记录答案后需要不断移动 i，l 和 r，对相同的值去重

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < nums.length - 1; i ++) {
            if (nums[i] > 0) return ans;
            int l = i + 1, r =  nums.length - 1;
            while (l < r) {
                int t = nums[i] + nums[l] + nums[r];
                if (t < 0) l ++;
                else if (t > 0) r --;
                else {
                    List<Integer> res = new ArrayList<>();
                    res.add(nums[i]); res.add(nums[l]); res.add(nums[r]);
                    ans.add(res);
                    while (l + 1 < r && nums[l] == nums[l + 1]) l ++;
                    while (r - 1 > l && nums[r] == nums[r - 1]) r --;
                    l ++; r --;
                }
            }
            while(i + 1 < nums.length && nums[i] == nums[i + 1]) i ++;
        }
        return ans;
    }
}
```

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i ++) {
            if (nums[i] > 0) return ans;
            int l = i + 1, r = nums.size() - 1;
            while (l < r) {
                int t = nums[i] + nums[l] + nums[r];
                if (t > 0) r --;
                else if (t < 0) l ++;
                else {
                    vector<int> res;
                    res.push_back(nums[i]); res.push_back(nums[l]); res.push_back(nums[r]);
                    ans.push_back(res);
                    while (l + 1 < r && nums[l] == nums[l + 1]) l ++;
                    while (r - 1 > l && nums[r] == nums[r - 1]) r --;
                    l ++, r --;
                }
            }
            while (i + 1 < nums.size() && nums[i] == nums[i + 1]) i ++;
        }
        return ans;
    }
};
```

****

## [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

****

- 双指针
- 首先，用 idx 从左向右找到第一个不是 0 的位置，设其为蓄水池左边界
- 设 i 为蓄水池右边界，i 不断向右移动，如果 height[i] >= height[idx]，说明后续的池子将以 height[i] 为左边界蓄水
- 此时，需要更新 idx 到 i 之间接到的雨水，设当前左边界高度为 t = height[idx]，不断循环 ans += t - height[idx ++]
- 若 idx < height.length，说明存在某个位置 height[idx] 为最点，导致后续蓄水池不再以此边界更新，因此需要倒着再来一遍

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int idx = 0;
        while (idx + 1 < height.length && height[idx] == 0) idx ++;
        for (int i = idx; i < height.length; i ++) {
            if (height[i] >= height[idx]) {
                int t = height[idx];
                while(idx < i) {
                    ans += t - height[idx ++];
                }
            }
        }
        if (idx < height.length) {  // 倒着同理再算一遍
            int r = height.length - 1;
            while (r - 1 > idx && height[r] == 0) r --;
            for (int i = r; i >= idx; i --) {
                if (height[i] >= height[r]) {
                    int t = height[r];
                    while (r > i) {
                        ans += t - height[r --];
                    }
                }
            }
        }
        return ans;
    }
}
```

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0;
        int idx = 0;
        while (idx + 1 < height.size() && height[idx] == 0) idx ++;
        for (int i = idx; i < height.size(); i ++) {
            if (height[i] >= height[idx]) {
                int t = height[idx];
                while (idx < i) {
                    ans += t - height[idx ++];
                }
            }
        }
        if (idx < height.size()) {
            int r = height.size() - 1;
            while (r - 1 > idx && height[r] == 0) r --;
            for (int i = r; i >= idx; i --) {
                if (height[i] >= height[r]) {
                    int t = height[r];
                    while (r > i) {
                        ans += t - height[r --];
                    } 
                }
            }
        }
        return ans;
    }
};
```

****

## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

****

- 滑动窗口
- 设 vis 存储当前窗口中已经存在的元素
- 令 j 为窗口的左边界，i 为窗口的右边界
- 循环向左移动 i，每次都将 s.charAt(i) 加入 vis
- 如果 vis 中在加入之前已经存在 s.charAt(i)，说明窗口中已经重复
- 因此需要不断缩小左边界，直到将某个 s.charAt(j) == s.charAt(i) 移出窗口
- 每次循环都要更新 vis 的最大长度即为答案

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length() <= 1) return s.length();
        Set<Character> vis = new HashSet<>();
        int ans = 1;
        for (int i = 0, j = 0; i < s.length(); i ++) {
            if (vis.contains(s.charAt(i))) {
                while (j <= i && vis.contains(s.charAt(i))) {
                    vis.remove(s.charAt(j ++));
                }
            }
            vis.add(s.charAt(i));
            ans = Math.max(ans, vis.size());
        }
        return ans;
    }
}
```

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.size() <= 1) return s.size();
        int vis[200] = {0};
        int ans = 1;
        int idx = 0;  // idx 记录窗口中已经存在的元素
        for (int i = 0, j = 0; i < s.size(); i ++) {
            if (vis[s[i]] == 1) {
                while (j <= i && vis[s[i]] == 1) vis[s[j ++]] --, idx --;
            }
            vis[s[i]] ++; idx ++;
            ans = max(ans, idx);
        }
        return ans;
    }
};
```

****

## [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

****

- 滑动窗口
- 首先，用 res 数组统计 p 中每个字符的数量
- 设 j 为窗口的左边界，i 为窗口的右边界，用 vis 数组统计当前窗口中的每个字符数量
- 让 i 不断向右移动，每次移动都使得 vis[s.charAt(i)] ++
- 如果 i - j + 1 > p.length() 说明窗口过大，需要收缩左边界，同时将窗口 vis 统计的左边界字符移除一个，即 vis[s.charAt(j ++)] --;
- 如果 i - j + 1 == p.length()，则需要判断窗口内含每个字符数量和 p 是否相等，即循环判断 vis 和 res 每个字符数量即可

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int[] res = new int[26];
        List<Integer> ans = new ArrayList<>();
        for (int i = 0; i < p.length(); i ++) res[p.charAt(i) - 'a'] ++;
        int[] vis = new int[26];
        for (int i = 0, j = 0; i < s.length(); i ++) {
            vis[s.charAt(i) - 'a'] ++;
            if (i - j + 1 > p.length()) vis[s.charAt(j ++) - 'a'] --;
            if (i - j + 1 == p.length()) {
                int flag = 0;
                for (int k = 0; k < 26; k ++) {
                    if (res[k] != vis[k]) {
                        flag = 1; break;
                    }
                }
                if (flag == 0) ans.add(j);
            }
        }
        return ans;
    } 
}
```

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int res[26] = {0}, vis[26] = {0};
        vector<int> ans;
        for (auto op : p) res[op - 'a'] ++;
        for (int i = 0, j = 0; i < s.size(); i ++) {
            vis[s[i] - 'a'] ++;
            if (i - j + 1 > p.size()) vis[s[j ++] - 'a'] --;
            if (i - j + 1 == p.size()) {
                bool flag = 1;
                for (int k = 0; k < 26; k ++) {
                    if (vis[k] != res[k]) {
                        flag = 0; break;
                    }
                }
                if (flag) ans.push_back(j);
            }
        }
        return ans;
    }
};
```

****

## [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

****

- 前缀和
- 遍历 nums，用 cnt += nums[i] 记录前 i 个元素的和及其数量
- 判断若之前已经存在前缀和的值为 cnt - k，说明存在连续的某个区间符合条件
- 答案为这个值的前缀和数量相加

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int ans = 0, cnt = 0;
        HashMap<Integer, Integer> vis = new HashMap<>();
        vis.put(0, 1);
        for (int i = 0; i < nums.length; i ++) {
            cnt += nums[i];
            if (vis.containsKey(cnt - k)) {
                ans += vis.get(cnt - k);
            }
            vis.put(cnt, vis.getOrDefault(cnt, 0) + 1);
        }
        return ans;
    }
}
```

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int ans = 0, cnt = 0;
        map<int, int> vis;
        vis[0] = 1;
        for (auto p : nums) {
            cnt += p;
            ans += vis[cnt - k];
            vis[cnt] ++;
        }
        return ans;
    }
};
```

****







